非线性数据结构（树）部分新增最优二叉搜索树问题，详细过程如下：
    树结构中最优二叉搜索树算法正确性,该算法能将非线性数据结构(二叉搜索树)映射为备忘录(二维表m_bst),设计过程如下：
a．前后置断言
    问题描述:给定n个有序的关键字序列D={d1, d2, …,dn},其查找概率分别是{p1, p2, …,pn},
最优二叉搜索树是以这n个关键字构造的二叉搜索树中具有最少平均比较次数的二叉搜索树.
设T(i,j)是由关键字{di,…, dj}(1≤i≤j≤n)构成的二叉搜索树,w[i,j]表示T(i,j)的权重,
即pi到pj的和,m_bst[i,j]表示二叉搜索树T(i,j)的最小平均比较次数.
    求解最优二叉搜索树函数式定义如下:
function min_wpl_nat :: "nat ⇒ nat ⇒ (nat list list) ⇒ nat" where
"min_wpl_nat i j W =
  (if i > j then 0
   else if i=j then W!i!j  
   else min_list (map (λk. min_wpl_nat i (k - 1) W + min_wpl_nat (k + 1) j W + W!i!j) [i..<j+1]))"
by auto
termination 
  by (relation "measure (λ(i, j, W). j - i+1)") auto
    根据2.1节动态规划类算法程序规约(前置条件P:length m ≥1;后置条件Q:x=length l ∧ m!u!v=),
可以得出最优二叉搜索树问题的程序规约,在该问题中r表示遍历m的外循环变量,
即x为r;依据其算法的遍历方式最终结束跳出循环时r的取值为length m[1],即l=m[1];
u和v分别表示最后目标问题的阶段和状态,u=1,v = length (m[1])-1.
    综上所述,最优二叉搜索树的程序规约为:
    前置条件P:length m_bst ≥1
    后置条件Q:r=length (m_bst[1]) ∧ m_bst!u!v=min_wpl u v λ（λ上面加横线）

b．递推关系式 
    依据文中2.2节动态规划类算法递推关系式的归纳,可得最优二叉搜索树的递推关系式归纳步骤如下:
【步骤RC 1】定义阶段和状态:以关键字序列D个数n来划分阶段,则阶段变量i表示关键字序列D的第i个关键字,
           状态变量j表示D的第j个关键字.
【步骤RC 2】确定决策:能够进入到判断第 i 个关键字到第 j 个关键字的最小平均比较次数的决策,用阶段i',状态j'表示.
【步骤RC 3】给出允许决策集合：求解关键字{di,…,dj}(1≤i≤j≤n)构成的二叉搜索树的最小平均比较次数,
            需要选择一个关键字dk(i≤k≤j)作为二叉搜索树的根结点求出所有可能二叉树的平均比较次数.
           当dk(i≤k≤j)作为二叉搜索树的根结点时,左子树对应的关键字为{di,…, dk},即i'的取值是i,状态j'的取值是k;
           右子树的关键字为{dk+1,…,dj},即i'的取值是k+1,状态j'的取值是j.综上可得允许决策集合D(i,j)={(i,k),(k+1,j)}(i≤k≤j).
【步骤RC 4】定义函数:
          辅助函数X(i,j)表示dk(i≤k≤j)作为二叉搜索树的根结点时,左子树最小平均比较次数m_bst[i,k-1]、右子树最小平均比较次数m_bst[k+1,j]和W[i,j]之和;
          依赖函数t表示dk(i≤k≤j)作为二叉搜索树的根结点时,所有可能的情况下平均比较次数m_bst[i,k-1]+m_bst[k+1,j]+W[i,j]之间的比较;
          特殊情况是k=i=j时只有一个关键字时,平均比较次数为W[i,j];
          最优二叉搜索树求解的是最小平均比较次数,所以最优函数opt表示的是min;
          F[i,j]表示求解最优决策表m_bst[i,j],m_bst[i,j]表示二叉搜索树T(i,j)平均比较次数取得的最优解;
          对于最优二叉搜索树分情况讨论递推关系式,判断的是位置关系,因此关于i的函数Ji是取i的值,关于j的函数Jj是取j的值,
          关于i,j的判断函数Judge是判断i和j的大小.在最优二叉搜索树问题中，i>j部分都是0，所以只判断i≤j部分.

      定义函数	         最优二叉搜索树
   辅助函数X(i,j)	 m_bst[i,k-1]+m_bst[k+1,j]+W[i,j]    (i≤k≤j)

    依赖函数t	         m_bst[i,j]=W[i,j] 
                           or
                       m_bst[i,j]表示k所有可能的情况下，
                       m_bst[i,k-1]+m_bst[k+1,j]+W[i,j] 之间的比较 

   最优函数opt	              min
   最优指标函数F[i,j]        m_bst[i,j]
   判断函数Judge           i=j    or  i<j

【步骤RC 5】归纳最优二叉搜索树的递推关系式,依据2.2节归纳的递推关系式和对函数的实例化,
           可得最优二叉搜索树的递推关系式:

           W[i,j]                                                i=j
m_bst =   
           min (i≤k≤j) {m_bst[i,k-1]+m_bst[k+1,j]+W[i,j]}        i<j



c 循环不变式
      根据2.3节动态规划类算法循环不变式的构造和给出的函数式定义,可得最优二叉搜索树的内外循环不变式,如下所示.

循环不变式构造步骤	                             外循环不变式构造	                                       内循环不变式构造
【步骤INV 1】给出循环变量范围	                  r≤length m!1∧ r≥1                                      r<length m!1∧ r≥1
                                            ∧i≥0 ∧ i≤length m-r+1                                  i≥0 ∧ i≤length m-r+1

	  
【步骤INV 2】确定求解问题变化规律	             (∀k. k < r ⟶                                             (∀k. k < r ⟶ 
                                               ( ∀ i. i<length m - r +1⟶                                ( ∀ i. i<length m - r +1⟶
                                                  m!i!(i+k-1) = min_wpl i (i+k-1) W ))	                       m!i!(i+k-1) = min_wpl i (i+k-1) W ))
                                                                                                       ∧(∀k. k < i ⟶ 
                                                                                                       m!k!(k + r - 1) = min_wpl k (k + r - 1) W )


【步骤INV 3】满足二维最优决策表性质	                 length m ≥1                                            length m ≥1
                                            ∧(∀k .k<length m ⟶ length (m!k) =                        ∧(∀k .k<length m ⟶ length (m!k) = 
                                            length (m!(k-1)) ∧ length (m!k)≥1)                            length (m!(k-1)) ∧ length (m!k)≥1 )             
                                          ∧length (m!1) = length m	                                    ∧length (m!1) = length m

【步骤INV4】循环不变式	                       INV{INV 1 ∧ INV 2 ∧ INV 3}	                                INV{INV 1 ∧ INV 2 ∧ INV 3}

     其中,在步骤INV 1中给出循环变量范围时,循环变量的下界确定依据的是归纳的最优二叉搜索树问题递推关系式,要求递推关系式等式两边满足所要求解的阶段和状态大于等于0,
可得 j≥0和i≥0,然而在最优二叉搜索树问题中阶段i即内循环变量,状态j是由外循环变量r和内循环变量i表示的即j=i+r-1,则有循环变量满足r>=1,i>=0,即a下=1,b下=0;
循环变量的下界依据遍历二维决策表m的方式,即 r≤length m!1; i≤length m-r+1,即a上=length m！1,b上=length m-r+1.在步骤INV 2中确定求解问题变化规律时,
需要确定,即对应最优二叉搜索树问题的函数式定义min_wpl i j W;在步骤INV 3中最优二叉搜索树问题满足length (m!1)=length m.
综上可得,最优二叉搜索树问题的外循环不变式和内循环不变式分别是INV_DP_E(length m!1,1,length m-r+1,0,min_wpl,W)
和INV_DP_I(length m!1,1,length m-r+1,0,min_wpl,W).

d．生成VCG代码
    根据2.4节编写IMP代码的过程和上述归纳的最优二叉搜索树问题递推关系式,可以很快实例化相应的IMP 代码,
因为IMP代码与VCG循环体高度相似,过程略.通过以上最优二叉搜索树问题的问题规约、递推关系式、循环不变式,
在 Isabelle/HOL中利用VCG对其生成验证条件的关键代码,对应算法1.
算法1 ：最优二叉搜索树
1.lemma optbst: "VARS m i j r W k 
2.{length m ≥ 1 } //前置条件
3.r := 1; j := 1; i := 0;
4.m := [[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],
5.     [0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0]];
6.W := [[0, 0, 0, 0, 0, 0, 0],[0, 1, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0, 0],[0, 0, 0, 1, 0, 0, 0],
7.     [0, 0, 0, 0, 1, 0, 0],[0, 0, 0, 0, 0, 1, 0],[0, 0, 0, 0, 0, 0, 1]];
8.WHILE r ≤ length (m!1) - 1
9.INV {INV_DP_E(length m!1,1,length m-r+1,0,min_wpl,W)}//外循环不变式
10.DO
11.            i := 0;
12.           WHILE i ≤ length m - r
13.           INV {INV_DP_I(length m!1,1,length m-r+1,0,min_wpl,W)} //内循环不变式
14.           DO
15.                 IF i = (i + r - 1) THEN   m := list_list_update m i (i + r - 1) (W!i!(i + r - 1))
16.                 ELSE     m := list_list_update m i (i + r - 1) 
17.        (Min {(m ! i ! (k - 1)) + m ! (k + 1) ! (i + r - 1) + W!i!(i + r - 1) | k. i ≤ k ∧ k <  (i + r - 1 + 1)})
18.                 FI;
19.                 i := i + 1
20.OD;
21.r := r + 1
22.OD
23.{ r = length (m!1)  ∧m!1!( length (m!1)-1) = min_wpl 1 ( length (m!1)-1) W }"//后置条件





